# Работа с Git
## Проверка наличия установленного Git

В терминале выполнить команду ```git  ---version```

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## Установка Git

[Загружаем последнюю версию Git с сайта https://git-scm.com/download](https://git-scm.com/download)

Устанавливаем с настройками по умолчанию.

## Настройка Git

После первого входа, необходимо представиться системе.

В терминале прописываем следующие команды:

```git config --global user.name``` «Ваше имя англ буквами»

```git config --global user.email``` ваша_почта@example.com

Первая команда запомнит Ваше имя в системе, вторая запомнит Ваш e-mail. Желательно указывать реальный адрес почты и имя, это упростит командную работу.

Далее необходимо инициализировать репозиторий Git, место где будут храниться файлы отслеживаемые системой контроля версий.

Для этого через терминал используем команду  `git init` с локальной ссылкой на папку, где будут храниться файлы, изменение которых необходимо будет отслеживать.

Например:
> ```git init C:\Users\%username%\Desktop\Homework#1```

Далее создаем файл в данном репозитории и добавляем его в систему контроля версий.

Для этого используем команду `git add` и далее указываем имя файла который необходимо добавить. 

Например:
> ```git add .\Homework1.md```

Минутка лайфхаков:

>*Можно использовать кнопку TAB на клавиатуре, тогда в команде `add` имя файла подтянется автоматически.*

>*Если Вы испольуете VSC, при запуске в стартовом окне "Начало работы" представится возможность выбрать папку, файлы в которой будут остлеживаться контролем версий, и затем просто прописать команду `git init` без точного указания пути к папке*

После добавления файла также необходимо использовать команду `git commit -m "Ваш комментарий"` , для того чтобы система начала отслеживать изменения в нём. Это своеобразная точка отсчета контроля версий файла, после которой появится возможность запоминать все последующие изменения файла и при необходимости возвращаться к предыдущим версиям.

Например:
>```git commit -m "Создали файл"```

Таким образом, подводя итоги в результате вышеописанных действий Вы:
1. Представились системе Git, указали своё имя и e-mail.
2. Инициализировали репозиторий в котором система будет отслеживать изменения файлов.
3. Начали контролировать версию первого файла, дальнейшие изменения в нём система будет отслеживать.

## Основные команды в Git

Вводя в терминал следующие команды, Вы сможете отслеживать изменения в файлах, возвращаться к предыдшим версиям своих файлов, искать и исправлять ошибки, откатывать изменения.
1. После изменения файла, которые вы хотите сохранить, необходимо использовать команды `git add <имя файла>` и команды `git commit -m  "комментарий"`. 

    Команды добавят текущую версию файла в историю изменений с комментарием о внесенных изменениях в файл.
    
     *ВАЖНО! Не забывайте сохранять файл перед использованием данных команд, командами ctrl+s или cmd+s (Mac)*

    Пример последовательности написания команд в терминале:

    > `git add <имя файла>` 

    > `git commit -m "Комментарий"`
2. Следующая команда `git status` покажет проиндексированные но не отслеживаемые файлы, то есть когда Вы внесли изменения в файл, сохранили его, но не выполнили команды из п.1., т.е. не "запомнили" системой новую версию.
    
    Пример того, что Вам покажет программа, при наличи подобных изменений:
    > Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   Homework1.md

    Система сама подскажет Вам команды, в зависимости от того, что Вы хотите сделать в данной ситуации `git restore <имя файла>` для отката изменений, либо `git add <имя файла>` для сохранения и последующего `commit` этого файла.
3. Для просмотра истории изменений используйте команду `git log`, она покажет список  Ваших `commit` `ов с комментариями которые Вы указывали, а также хэш-код версий файла, с помощью него Вы сможете вернуться к необходимой версии и об этом расскажем чуть позже.

    Пример вывода данной операции:
    > commit a72a59006b28a1e42209066f0f2531a68bde9aeb
    
    >Author: Evgeniy <ugin2308@mail.ru>

    >Date:   Mon Jan 17 00:41:51 2022 +0300

    >Создан раздел Основные команды гит, добавлен п.1
4. Для просмотра разницы между текущей сохраненной но `не запомненной` и последней сохраненной `запомненной` версией файла, или `запомненной` ещё ранее через команду `commit`, можно использовать команду `git diff` с указанием хэш кода `commit` (для более ранних версий) который можно получить c помощью команды `git log` указанной в п.3. Результатом данной операции будет отображения всех изменений внесенных в файл относительно версии к сравнению.
    
    Пример написания данной команды, с использованием хэш кода из п.3
    > ```git diff a72a59```
    
    *Примечание: не обязательно брать хэш-код целиком, Git достаточно первых 4-6 символов кода для того чтобы распознать конкретную версию. Если нет необходимости сравнивать с версиями предшествующими последнему `commit` хэш-код указывать не требуется.*
5. Для просмотра одной из ранее сохраненных версий файла, можно воспользоваться командой `git checkout <хэш код commit>`. В этом случае Вы перейдете к версии файла которая была сохранена ранее, для правок или просмотра. Для того, чтобы вернуться к последней сохраненной версии файла используйте комманду `git checkout master`.
    
    Пример написания данной команды, с использованием хэг кода из п.3
    > `git checkout a72a59`
    
    Для выхода из режима просмотра
    > `git checkout master`

    Также возможно использовать комманды `git add` и `git commit` если нет необходимости возвращаться к "актуальной" версии.

  ## Ветветки в Git.


Помимо команд указаных ранее, Git может предложить пользователю такую функцию как создание "веток" в процессе сохранений файла. Которая очень удобна, например при одновременной работе над файлом нескольких пользователей.

# Создание новой ветки

Для создания новой ветки проекта используйте команду `- git branch <new branch name>`

Для проверки своего "местоположения" используйте команду `- git branch` где симовлом `(*)` будет отмечена ветка в котрой вы сейчас находитесь.

Для перехода в другую ветку используйте команду `git checkout <branch_name>`

Так выглядит типовой лог операций при создании новой ветки с последующей проверкой своего местоположения и перемещение в дереве версий.


![P14](Primer14.jpg)

Действия в новой ветке возможно записывать и сохранять абсолютно также как и в основной ветке проекта. Комманды `-git add <filename>`, `git commit -m "комментарий"` выполняют те же роли, что в ветке мастер, по прежнему остается возможным контроль версий файла, команда `git log` покажет все `commit` `ы, которые были в файле c деталезацией по веткам. 

Лог при этом будет следующий:

![P17](Primer17.jpg)


# Функциональность.

__*Создаю конфликт:*__

Иногда, ряд веток становится не нужным для дальнейшего контроля, соответственно их можно удалить из истории. Для этого можно воспользоваться командой `git branch -d <branch_name`>. 

Пример последовательности данной операции Вы можете наблюдать на картинке ниже:
![P15](Primer15.jpg)

![P16](Primer16.jpg)

* * *


*NONAME<> *

![primer3](Primer3.jpg)

 Пример для коммита.
![primer4](Primer5.jpg)


## Конфликтные ситуации

*Возникают различные конфликтные ситуации, по тем или иным причинам.*

Как я понял Git подразумевает структурированную работу с документом, чтобы участки редактирования были заранее оговорены, т.к. замена больших блоков отнимает много сил на анализ расхождений. Тем не менее, из данного файла я создал две ветки, одна из которых `scrsh` а другая `konflikt`. Первой была крайняя ветка. В этой ветке я внёс исправление в текущий блок. Сохранил файл и перешел в ветку `scrsh` , из названия можно догадаться что это скриншоты конфликтов и не только при работе с ветками.

Конфликт возникает, когда заполнение файла идет не последовательно, новые блоки не увязываются между собой и надо сохранять файл постоянно, отслеживая где и в каком состоянии его ветки на текущий момент, положительные `merge` агрегируя в ветке мастер, т.к. внеся изменения в дельта-ветки, и сливая их между собой, можно нарваться на то, что основной ствол уйдет в дельту. Либо будет последовательное ведение двух веток, контроль соответствий и понимая почему такая версия присутствует в проекте.

Например при добавлении ветки `scrsh` с упоряд. списком всех скринов, и после этого ветки `konflikt` то файл выдал ошибку такого рода:
>![P11](Primer11.jpg)

На выбор будет предложено либо принятие какого-то удного участка, либо оба варианта, либо сравить их между собой.

Это просто и легко когда у Вас разница в небольшом участке:
![P12](Primer12.jpg)


И гораздо сложнее на участках разного уровня:

![P7](Primer8.jpg)

* > Обратите внимание, сверху указана текущая версия HEAD и выделена зеленым цветом,Синим цветом выделено входящее изменение даннного участка файла. Когда строк много, могут возникнуть вопросы - Ответы на которые я дал в серии смежных merge веток `konflikt` и `scrsh`

Следует добавлять все изменения последовательно, резкие вставки губят.

Также верный способ избежать конфликтных ситуаций, сразу после `merge` и и решения по ситуации с конфликтом, следует незамедлительно сохранить файл через команды `git add` и `git commit`, иначе при переходе в другие ветки и правки в них, возникнет конфликт версионности.
Вот как визуально проявляется информация о том, что файл находится в состоянии конфликта:
![P13](Primer13.jpg)


* >Не совсем понял как, но есть вероятность, что если после коммита о решенном конфликте добавлять новую информацию в `master` и делать повторный `add + commit` то новая версия не потянет за собой конфликта веток, нежели при последующем переходе в ветку с которой был сделан `merge`. "*ушел пробовать*"
## Скриншоты конфилктов с кратиким описанием

__Здесь будет список скриншотов по возрастанию, для проверки того, сольется ли эта ветка с мастером.__
После успешного слияния файла не возникакие никаких конфликтов, просто новая часть ложиться вместо старой.
Но если блоки большие то все будет как на скриншоте 9.
Добавлю эту же информацию в блок конфликтных ситуаций, повторно, ведь я уже потерял его отредактированный однажды. 
>git *Напоминаю, что команда по слиянию веток `git merge <branch_name>`*

1. ![P1](Primer1.jpg)
2. ![P2](Primer2.jpg)
3. ![P3](Primer3.jpg)
4. ![P4](Primer4.jpg)
5. ![P5](Primer5.jpg)
6. ![P6](Primer6.jpg)
7. ![P7](Primer7.jpg)
8. ![P8](Primer8.jpg)
9. ![P9](Primer9.jpg)
10. ![P10](Primer10.jpg)
11. ![P11](Primer11.jpg)
12. ![P12](Primer12.jpg)
13. ![P13](Primer13.jpg)
14. ![P14](Primer14.jpg)
15. ![P15](Primer15.jpg)
16. ![P16](Primer16.jpg)

# Послесловие 

# Мысли в слух, смысловой блок для тесов сливания

Теперь стало понятным, что все добавления должны быть четко зафиксированы, и не стоит хранить супер древние версии файлов, во избежании конфликтов.
Последовательное сохранение и создание новых веток при необходимости важно.
Старые ветки желательно удалять, чтобы лишний раз не нарываться на конфликтные ситуации.
